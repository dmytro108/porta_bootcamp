## 1. Какие метрики реально важны для оценки методов удаления

Я перечислю метрики из прокомментирую их **полезность** и **ограничения**.

### 1.1. Пропускная способность: `rows_deleted_per_second`

**Что это:**  
Сколько строк в среднем удаляется в секунду:

- для батчей: `rows_in_batch / duration_of_batch`;
    
- общая: `total_deleted / total_time`.
    

**Зачем нужно:**

- позволяет сравнить **разные методы**:
    
    - батч-DELETE с `LIMIT 1000` vs `LIMIT 10000`;
        
    - `pt-archiver` vs собственный скрипт;
        
    - copy+rename vs «прямой» батч-DELETE;
        
- позволяет увидеть, **как падает скорость** по мере роста нагрузки/фрагментации.
    

**Ограничения:**

- если параллельно много других запросов, то «низкая скорость» может быть из-за общей нагрузки, а не самого метода;
    
- `ROW_COUNT()` показывает размер последнего батча, а не всей операции — надо аккуратно суммировать.
    

**Вывод:** это **одна из ключевых метрик** для сравнения методов.

---

### 1.2. Общее время операции

**Что это:** время от начала до полного окончания очистки.

**Зачем нужно:**

- прикинуть: уложимся ли в «окно обслуживания»;
    
- сравнить: какой подход «съел» меньше времени — батчи vs copy+rename vs партиции.
    

**Ограничения:**

- если метод работает «очень мягко» (маленькие батчи + большие паузы), суммарное время будет больше, но это может быть **осознанный компромисс** ради минимального влияния на прод.
    

**Вывод:** тоже **важная интегральная метрика**, но её всегда нужно интерпретировать вместе с влиянием на прод и репликацию.

---

### 1.3. Влияние на репликацию: `Seconds_Behind_Source` / `Seconds_Behind_Master`

**Что это:** насколько SQL-поток реплики отстаёт от мастера по времени последнего применённого события.

**Зачем нужно:**

- это главный индикатор того, **насколько сильно операция «душит» реплики**;
    
- позволяет:
    
    - сравнить разные методы;
        
    - «подстроить» размер батча/паузы: если lag начинает расти — уменьшаем `LIMIT` или добавляем `SLEEP`.
        

**Ограничения:**

- показатель **приблизительный**:
    
    - если реплика остановлена или SQL-поток не работает, `Seconds_Behind_*` может быть `NULL`;
        
    - если IO-поток встал, но SQL-поток всё применил — лаж может показывать 0, хотя новые события не приходят;
        
- хорошо бы параллельно смотреть состояние `Replica_IO_Running`, `Replica_SQL_Running` и размер relay log.
    

**Вывод:** для master–slave это **критическая метрика**, без неё сравнивать методы очистки — почти слепая работа.

---

### 1.4. InnoDB-метрики: `Innodb_rows_deleted`, `Innodb_row_lock_time`, history list length

**Что они дают:**

- `Innodb_rows_deleted` — глобальный счётчик **всех** удалённых строк с момента старта сервера.
    
- `Innodb_row_lock_time` — суммарное время ожидания **строчных блокировок**.
    
- history list length (длина очереди истории) — показывает, насколько сильно база отстаёт с **purge** старых версий.
    

**Зачем нужно:**

- по разнице `Innodb_rows_deleted` до/после операции можно проверить, **ожидали ли мы именно столько удалений** (хоть и косвенно);
    
- рост `Innodb_row_lock_time` во время операции — индикатор, что мы **создаём много конфликтов**;
    
- history list length:
    
    - если быстро растёт во время удаления — purge не успевает, может ухудшиться производительность всей базы.
        

**Ограничения:**

- это **глобальные счётчики** — они учитывают не только вашу операцию удаления, а всё, что происходит в системе;
    
- чтобы использовать их для анализа конкретной операции, нужно:
    
    - фиксировать значения **сразу до начала**;
        
    - и **сразу после окончания**;
        
    - параллельно понимать, насколько шумный у вас прод.
        

**Вывод:** это **вспомогательные метрики**, полезные для оценки «побочных эффектов» (блокировки, отставание purge), но не основная оценка скорости.

---

### 1.5. Размер таблицы и индексного пространства: `DATA_LENGTH`, `INDEX_LENGTH`, `DATA_FREE`

**Что это:**

```sql
SELECT TABLE_SCHEMA, TABLE_NAME,
       DATA_LENGTH, INDEX_LENGTH, DATA_FREE
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mydb' AND TABLE_NAME = 'big_table';
```

- `DATA_LENGTH` — размер данных таблицы;
    
- `INDEX_LENGTH` — размер индексов;
    
- `DATA_FREE` — свободное (фрагментированное) место, которым таблица **может воспользоваться**, но ОС пока не вернули.
    

**Зачем нужно:**

- понять, **сколько диска на самом деле освободил тот или иной метод**:
    
    - `TRUNCATE` / `DROP PARTITION` — освобождают физически;
        
    - массовый `DELETE` может **оставить много free-space внутри файла**, который ОС не видит как освободившийся;
        
- можно оценить, нужна ли дополнительная **дефрагментация** (`OPTIMIZE TABLE` / rebuild).
    

**Ограничения:**

- значение `DATA_FREE` зависит от версии/engine и не всегда идеально точно показывает «дырки»;
    
- сравнивать лучше **разницу** до/после, а не абсолютные числа.
    

**Вывод:** это **важная метрика для сравнения методов именно по освобождению диска** (не только по скорости).

---

### 1.6. Latency других запросов

В тексте я упомянул «рост средней латентности SELECT/UPDATE», но **явных SQL-примеров не дал** — это скорее зона для внешнего мониторинга:

- `performance_schema` может дать:
    
    - среднее время `SELECT`/`UPDATE`/`INSERT` по классу запросов;
        
- но чаще это смотрят в Prometheus/Grafana, PMM и т.п.
    

**Вывод:** для чистого «учебного» сценария эту метрику можно опустить, но в проде она очень важна: может оказаться, что метод даёт нормальную скорость удаления, но **убивает работу пользовательских запросов**.

---

### 1.7. `performance_schema.events_statements_summary_by_digest`

В примере:

```sql
SELECT
  DIGEST_TEXT,
  COUNT_STAR              AS exec_count,
  SUM_TIMER_WAIT/1e12     AS total_time_sec,
  SUM_ROWS_AFFECTED       AS total_rows,
  (SUM_ROWS_AFFECTED /
   (SUM_TIMER_WAIT/1e12)) AS rows_per_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE 'DELETE FROM `big_table`%'
ORDER BY total_time_sec DESC
LIMIT 5;
```

**Что хорошо:**

- `SUM_TIMER_WAIT` в picoseconds → деление на `1e12` даёт секунды;
    
- `SUM_ROWS_AFFECTED` — сколько строк всего затронули запросы данного «типа»;
    
- `rows_per_sec` даёт среднюю скорость по этому типу запроса.
    

**Что нужно поправить/уточнить:**

1. Нужна защита от деления на 0:
    
    ```sql
    SUM_ROWS_AFFECTED /
      NULLIF(SUM_TIMER_WAIT/1e12, 0)
    ```
    
2. Фильтр `DIGEST_TEXT LIKE 'DELETE FROM \`big_table`%'` — **эвристический**:
    
    - DIGEST_TEXT нормализуется (убирает константы, форматирует запрос);
        
    - иногда лучше смотреть по `DIGEST` (если заранее его знаете), либо по более аккуратному шаблону.
        
3. `performance_schema` должен быть **включён** и соответствующие consumers/инструменты активированы — по умолчанию на некоторых инсталляциях часть из них выключена.
    

**Вывод:** подход в целом корректный, но его нужно воспринимать как **агрегированную статистику по типу запросов**, а не как точное измерение конкретной операции.

---

## 2. Проверка и аккуратная правка примеров сбора метрик

Теперь по конкретным кускам из прошлого ответа.

### 2.1. Стартовые замеры

```sql
SELECT TABLE_SCHEMA, TABLE_NAME,
       DATA_LENGTH, INDEX_LENGTH, DATA_FREE
FROM   information_schema.TABLES
WHERE  TABLE_SCHEMA = 'mydb' AND TABLE_NAME = 'big_table';

SHOW GLOBAL STATUS LIKE 'Innodb_rows_deleted';
SHOW GLOBAL STATUS LIKE 'Innodb_row_lock_time';

-- На реплике:
SHOW REPLICA STATUS\G   -- (или SHOW SLAVE STATUS\G для старых версий)
```

**Это корректно.**  
Чтобы сделать метрику полезной:

- запоминаем эти значения **перед началом** операции (например, в отдельную таблицу `metrics_log`);
    
- потом через `INSERT ... VALUES` записываем «после» и считаем разницу.
    

---

### 2.2. Измерение батчей и суммарной скорости

В прошлый раз я написал пример с использованием пользовательских переменных:

```sql
SET @t0 = NOW();
SET @deleted_total = 0;

DELETE FROM big_table
WHERE created_at < '2024-01-01'
ORDER BY id
LIMIT 10000;

SET @rows = ROW_COUNT();
SET @deleted_total = @deleted_total + @rows;
...
```

**Нюанс:** это корректно **только если весь цикл выполняется в одной сессии** (одном подключении).  
Если же ты вызываешь `mysql -e "..."` в каждом батче отдельно из shell-скрипта, то переменные `@t0`, `@deleted_total` будут каждый раз **обнуляться**.

Поэтому:

- либо делаешь цикл **целиком внутри одной сессии** (процедура/скрипт в `mysql`),
    
- либо переносишь накопление (`deleted_total`, время) на сторону **клиентского скрипта** (bash, Python).
    

**Более корректный учебный пример:**

> Вариант А: считаем всё на стороне клиента (рекомендую)

```bash
#!/usr/bin/env bash
BATCH=10000
TOTAL=0
T0=$(date +%s)

while true; do
  ROWS=$(mysql -N -e "
    DELETE FROM big_table
    WHERE created_at < '2024-01-01'
    ORDER BY id
    LIMIT ${BATCH};
    SELECT ROW_COUNT();
  " mydb)

  if [ "$ROWS" -eq 0 ]; then
    break
  fi

  TOTAL=$((TOTAL + ROWS))

  NOW=$(date +%s)
  ELAPSED=$((NOW - T0))
  if [ "$ELAPSED" -eq 0 ]; then ELAPSED=1; fi

  echo "Deleted batch: $ROWS rows, total: $TOTAL, avg: $((TOTAL / ELAPSED)) rows/sec"

  sleep 0.5
done
```

> Вариант Б: сделать хранимую процедуру / SQL-скрипт и крутить цикл внутри одной сессии  
> (подойдёт для учебного примера, но чуть громоздко для чата).

---

### 2.3. Репликация: сбор метрик

```sql
SHOW REPLICA STATUS\G
-- или: SHOW SLAVE STATUS\G
```

**Корректно, но полезно явно сказать:**

- смотрим:
    
    - `Seconds_Behind_Master` или `Seconds_Behind_Source`;
        
    - `Slave_IO_Running` / `Slave_SQL_Running` (или `Replica_IO_Running`, `Replica_SQL_Running` в новых версиях);
        
- логируем эти значения каждые N секунд **во время удаления** (через скрипт/мониторинг), чтобы построить график lag.
    

Это не ошибка в моём прошлом ответе, просто нужно сильнее акцентировать внимание, что одного числа «в конце» мало — нужна **динамика во времени**.

---

### 2.4. InnoDB history list length

Я упомянул «history list length», но не дал команды.  
Более честно так:

- либо смотреть через `SHOW ENGINE INNODB STATUS\G` (там есть строка `History list length = ...`);
    
- либо использовать `information_schema.INNODB_METRICS` и искать соответствующий metric:
    

```sql
SELECT NAME, COUNT
FROM information_schema.INNODB_METRICS
WHERE NAME = 'trx_rseg_history_len';
```

**Это дополнение**, а не исправление — но хорошо бы иметь конкретику.

---

### 2.5. Итог по корректности

- **Размер таблицы** (через `information_schema.TABLES`) — корректно.
    
- **Global status** (`Innodb_rows_deleted`, `Innodb_row_lock_time`) — корректно, но нужно помнить, что это глобальные счётчики → использовать разницу до/после.
    
- **`SHOW REPLICA/SLAVE STATUS`** — корректно, но лучше посмотреть ещё `*_Running`.
    
- **`performance_schema.events_statements_summary_by_digest`** — корректно по идее, но:
    
    - добавить `NULLIF` при делении;
        
    - понимать, что это агрегат по «типам запросов».
        
- Пример с `@deleted_total` внутри SQL — **корректный только для одной сессии**, в реальной жизни проще считать на стороне скрипта.
    

---

## 3. Как связать метрики с выбором метода

Чтобы замкнуть круг, кратко: **что сравнивать между методами**.

- `rows_deleted_per_second` + `total_time`  
    → кто быстрее чистит таблицу.
    
- `Seconds_Behind_Source` (максимум и форма графика)  
    → кто меньше ломает репликацию.
    
- `DATA_LENGTH + INDEX_LENGTH` и `DATA_FREE` до/после  
    → кто лучше освобождает диск и меньше оставляет фрагментации.
    
- `Innodb_row_lock_time` (разница до/после)  
    → кто меньше создаёт блокировок и конфликтов.
    
- history list length  
    → насколько каждый метод «засоряет» undo и нагружает purge.
    
