# MySQL Cleanup Benchmark - Results Interpretation Guide

Guide for understanding and interpreting cleanup method test results.

## Table of Contents

- [Understanding Metrics](#understanding-metrics)
- [Comparing Methods](#comparing-methods)
- [Making Decisions](#making-decisions)
- [Performance Benchmarks](#performance-benchmarks)
- [What to Look For](#what-to-look-for)
- [Common Patterns](#common-patterns)
- [Example Analysis](#example-analysis)

---

## Understanding Metrics

### Primary Metrics

**rows_deleted_per_second** (Throughput):
- Most important metric for comparing speed
- Higher is better
- Formula: total_rows_deleted / duration_seconds
- Example: `5,063,000 rows/sec` (partition_drop is extremely fast)

**Duration**:
- Total cleanup time in seconds
- Lower is better
- Includes all operations (DELETE, DROP, OPTIMIZE, etc.)
- Example: `0.8s` (partition_drop), `45.2s` (batch_delete)

**Rows Deleted**:
- Exact count of removed rows
- Should match expected (~50% of dataset for default 10-day retention)
- Example: `5,031 rows deleted` from 10,000 total

### InnoDB Metrics

**Innodb_rows_deleted**:
- Cumulative counter of rows deleted
- Delta shows cleanup impact
- Example: Before: `10,500`, After: `15,531`, Delta: `5,031`

**Innodb_row_lock_time** (ms):
- Total time waiting for row locks
- Lower is better
- High values indicate contention
- Example: Delta `<100ms` is good, `>1000ms` indicates issues

**Innodb_row_lock_waits**:
- Number of times had to wait for row lock
- Lower is better
- Example: Delta `0` is ideal (no lock waits)

**History List Length**:
- Purge lag indicator
- Lower is better (<1000 is good)
- High values indicate purge thread can't keep up
- Example: `152` (healthy), `5000+` (problematic)

### Table Size Metrics

**DATA_LENGTH** (bytes):
- Size of table data
- Reduction shows space freed
- Example: Before: `5,242,880`, After: `2,621,440` (50% reduction)

**INDEX_LENGTH** (bytes):
- Size of indexes
- Should decrease proportionally with data
- Example: Before: `1,048,576`, After: `524,288`

**DATA_FREE** (bytes):
- Free space in allocated pages (fragmentation)
- Batch DELETE does NOT free this
- Example: After batch_delete: `2,621,440` (requires OPTIMIZE)

**Fragmentation Percentage**:
- Formula: `DATA_FREE / (DATA_LENGTH + INDEX_LENGTH) * 100`
- Lower is better (<5% is good)
- Example: After partition_drop: `0%`, After batch_delete: `35%`

### Replication Metrics

**Seconds_Behind_Source** (on replica):
- Replication lag in seconds
- Lower is better (<1s is excellent, <10s is good)
- Example: partition_drop: `<1s`, batch_delete: `5-15s`

**Max Replication Lag** (during cleanup):
- Peak lag observed
- Important for batch_delete (can spike)
- Example: batch_delete with 10K batches: `45s` peak lag

### Binlog Metrics

**Binlog Size Growth** (bytes):
- Amount of binlog generated by cleanup
- Indicates replication overhead
- Example: batch_delete: `~100 bytes per row`, partition_drop: minimal

### Batch DELETE Specific

**Per-Batch Throughput**:
- Rows deleted per second for each batch
- Typically degrades over time
- Example: Batch 1: `2000/s`, Batch 5: `1500/s`, Batch 10: `1000/s`

**Throughput Degradation**:
- Percentage decrease from first to last batch
- Expected: 20-40% degradation
- Example: `35% degradation` (normal)

---

## Comparing Methods

### Fair Comparison Requirements

For accurate comparison, ensure:

1. **Same dataset size**: All methods test with same row count
2. **Same data distribution**: ~50% old data, ~50% recent
3. **Clean baseline**: Each method starts with non-fragmented table
4. **Same environment**: Same load, same MySQL configuration
5. **Multiple runs**: Average results across 3-5 runs

### What to Compare

**Primary Comparison** (Speed):
```
| Method         | Throughput (rows/sec) | Duration (sec) |
| -------------- | --------------------- | -------------- |
| partition_drop | 5,063,000             | 0.8            |
| truncate       | 52,631                | 1.9            |
| copy           | 2,450                 | 20.4           |
| batch_delete   | 1,234                 | 40.6           |
```

**Replication Impact**:
```
| Method         | Max Lag (sec) | Avg Lag (sec) |
| -------------- | ------------- | ------------- |
| partition_drop | <1            | <1            |
| truncate       | <2            | <2            |
| copy           | 15            | 8             |
| batch_delete   | 45            | 12            |
```

**Space Recovery**:
```
| Method         | Space Freed | Fragmentation After |
| -------------- | ----------- | ------------------- |
| partition_drop | 100%        | 0%                  |
| truncate       | 100%        | 0%                  |
| copy           | 100%        | 0%                  |
| batch_delete   | 0%          | 35%                 |
```

**Availability**:
```
| Method         | Downtime     | Table Online? |
| -------------- | ------------ | ------------- |
| partition_drop | Brief lock   | 99.9%         |
| truncate       | Brief lock   | 99.9%         |
| copy           | Brief RENAME | 99.5%         |
| batch_delete   | None         | 100%          |
```

### Metric Priorities

**For Production Decision**:
1. **Selective cleanup**: Does it keep recent data? (disqualifies truncate)
2. **Speed**: How fast is it?
3. **Replication lag**: Acceptable lag?
4. **Space recovery**: Is OPTIMIZE TABLE needed?
5. **Availability**: Acceptable downtime?

---

## Making Decisions

### Decision Tree

```
Need selective cleanup (keep recent 10 days)?
│
├─ NO (delete everything)
│  └─ Use TRUNCATE (fastest, but removes ALL data)
│
└─ YES (keep recent data)
   │
   ├─ Is table partitioned by date?
   │  └─ YES → Use DROP PARTITION ⭐ (best: fast + selective)
   │
   └─ NO (not partitioned)
      │
      ├─ Can table be offline briefly (<1 min)?
      │  ├─ YES → Use COPY (good for defrag)
      │  └─ NO → Use BATCH DELETE (last resort)
      │
      └─ BATCH DELETE requires:
         - OPTIMIZE TABLE after (weekly)
         - Monitoring replication lag
         - Tuning batch size
```

### When to Use Each Method

**Use DROP PARTITION when**:
- ✅ Table is partitioned by date/time
- ✅ Need fastest cleanup
- ✅ Want minimal replication lag
- ✅ Want immediate space recovery
- **This should be your default choice if partitioning is available**

**Use TRUNCATE when**:
- ✅ Can delete ALL data (no retention requirement)
- ✅ Temporary/staging tables
- ✅ Batch processing tables
- ❌ NOT for production tables with retention requirements

**Use COPY when**:
- ✅ Table not partitioned
- ✅ Scheduled maintenance windows available
- ✅ Defragmentation is needed
- ✅ Brief downtime is acceptable
- ⚠️ Understand data loss risk during copy

**Use BATCH DELETE when**:
- ✅ Table must stay online 24/7
- ✅ Cannot use partitioning
- ✅ No maintenance windows
- ⚠️ Accept slower performance
- ⚠️ Plan for OPTIMIZE TABLE (weekly)
- ⚠️ Monitor replication lag

### Trade-offs Analysis

**DROP PARTITION**:
- ✅ Pros: Fastest, minimal lag, complete space recovery, no fragmentation
- ❌ Cons: Requires partitioning, partition boundaries must align with retention
- **Recommendation**: Use whenever possible

**BATCH DELETE**:
- ✅ Pros: Table stays online, no downtime
- ❌ Cons: Slowest, replication lag, NO space freed, high fragmentation
- **Recommendation**: Last resort when partitioning not available

**COPY**:
- ✅ Pros: Complete space recovery, no fragmentation
- ❌ Cons: Data written during copy is LOST, brief table lock
- **Recommendation**: Use during maintenance windows only

---

## Performance Benchmarks

### Expected Throughput Ranges

**10,000 rows**:
- partition_drop: 4,000-10,000 rows/sec
- truncate: 50,000+ rows/sec
- copy: 1,000-3,000 rows/sec
- batch_delete: 500-2,000 rows/sec

**100,000 rows**:
- partition_drop: 5,000-15,000 rows/sec
- truncate: 50,000-100,000 rows/sec
- copy: 2,000-4,000 rows/sec
- batch_delete: 1,000-2,500 rows/sec

**1,000,000 rows**:
- partition_drop: 10,000-50,000 rows/sec
- truncate: 100,000-500,000 rows/sec
- copy: 3,000-6,000 rows/sec
- batch_delete: 1,500-3,000 rows/sec

### Replication Lag Expectations

**No Concurrent Load**:
- partition_drop: <1 second
- truncate: <2 seconds
- copy: 5-15 seconds
- batch_delete: 5-30 seconds

**With Concurrent Load (20 ops/sec)**:
- partition_drop: <2 seconds
- truncate: <3 seconds
- copy: 15-60 seconds
- batch_delete: 30-120 seconds

### Fragmentation Expectations

**After Cleanup**:
- partition_drop: 0% (perfect)
- truncate: 0% (perfect)
- copy: 0% (perfect)
- batch_delete: 20-50% (requires OPTIMIZE)

---

## What to Look For

### Good Signs ✅

**Performance**:
- Throughput within expected range
- Duration consistent across runs
- Replication lag <10 seconds
- No lock waits or timeouts

**Data Integrity**:
- Rows deleted matches expected (~50% for 10-day retention)
- No data loss (except copy method)
- Date range correct after cleanup

**System Health**:
- Replication running normally
- No error messages
- Binlog size growth expected
- Disk space freed (except batch_delete)

### Red Flags ⚠️

**Performance Issues**:
- Throughput 50%+ below expected
- Duration 2x+ longer than expected
- Replication lag >60 seconds
- High lock wait times

**Data Issues**:
- Rows deleted doesn't match expected
- Unexpected data loss
- Incorrect date range after cleanup

**System Issues**:
- Replication stopped or lagging severely
- Error messages in logs
- Disk space not freed (partition_drop/copy)
- High fragmentation after partition_drop/copy

### Common Issues

**Batch DELETE Throughput Degradation**:
- Expected: 20-40% degradation
- Problem if: >50% degradation
- Solution: OPTIMIZE TABLE, reduce batch size

**High Replication Lag (batch_delete)**:
- Expected: <30 seconds average
- Problem if: >60 seconds sustained
- Solution: Reduce batch size, increase delay

**No Space Freed (batch_delete)**:
- Expected: DATA_FREE increases, DATA_LENGTH unchanged
- Problem if: Table size not decreasing
- Solution: Run OPTIMIZE TABLE

---

## Common Patterns

### Typical Results Pattern

**10K dataset, no concurrent load**:
```
| Method         | Duration | Throughput  | Lag | Space Freed         |
| -------------- | -------- | ----------- | --- | ------------------- |
| partition_drop | 0.8s     | 5,000,000/s | <1s | 100%                |
| truncate       | 1.9s     | 50,000/s    | <2s | 100%                |
| copy           | 20.4s    | 2,450/s     | 8s  | 100%                |
| batch_delete   | 40.6s    | 1,234/s     | 12s | 0% (needs OPTIMIZE) |
```

**Batch DELETE Degradation Pattern**:
```
| Batch | Rows Deleted | Throughput (rows/sec) | Lag (sec) |
| ----- | ------------ | --------------------- | --------- |
| 1     | 500          | 2,000                 | 2         |
| 2     | 500          | 1,900                 | 3         |
| 3     | 500          | 1,800                 | 4         |
...
10    | 500          | 1,200                | 8
```

### Performance Trends

**As Dataset Size Increases**:
- partition_drop: Linear scaling (consistent throughput)
- truncate: Linear scaling (very fast regardless)
- copy: Near-linear scaling (slightly slower with size)
- batch_delete: Sublinear scaling (degrades with size)

**With Concurrent Load**:
- partition_drop: Minimal impact (<10% slower)
- truncate: Minimal impact (<10% slower)
- copy: Moderate impact (20-40% slower)
- batch_delete: High impact (40-100% slower)

---

## Example Analysis

### Example 1: Typical Production Scenario

**Test Results**:
```
Dataset: 100,000 rows (50,000 old, 50,000 recent)
Concurrent Load: 20 ops/sec

| Method         | Duration | Throughput | Rows Deleted | Max Lag |
| -------------- | -------- | ---------- | ------------ | ------- |
| partition_drop | 6.2s     | 8,064/s    | 50,000       | 1.2s    |
| copy           | 95.3s    | 524/s      | 50,000       | 35.2s   |
| batch_delete   | 187.5s   | 266/s      | 50,000       | 68.4s   |
```

**Analysis**:
- partition_drop is 15x faster than copy, 30x faster than batch_delete
- Replication lag is acceptable for partition_drop (<2s)
- batch_delete causes significant lag (68s peak)

**Recommendation**: **Use DROP PARTITION**
- Fastest cleanup
- Minimal replication lag
- Complete space recovery
- No fragmentation

### Example 2: Non-Partitioned Table

**Test Results**:
```
Dataset: 50,000 rows (no partitioning available)
Concurrent Load: None

| Method       | Duration | Throughput | Fragmentation After |
| ------------ | -------- | ---------- | ------------------- |
| copy         | 42.1s    | 1,187/s    | 0%                  |
| batch_delete | 89.3s    | 560/s      | 38%                 |
```

**Analysis**:
- copy is 2x faster than batch_delete
- copy provides complete space recovery
- batch_delete requires OPTIMIZE TABLE (adds ~60s)

**Recommendation**: **Use COPY if maintenance window available**
- 2x faster overall (including OPTIMIZE time)
- Complete space recovery
- No fragmentation
- Run during low-traffic period to minimize data loss risk

### Example 3: 24/7 Operation Required

**Constraints**:
- Table must stay online 24/7
- No partitioning available
- No maintenance windows

**Test Results**:
```
| Method       | Duration | Table Downtime | Space Freed         |
| ------------ | -------- | -------------- | ------------------- |
| batch_delete | 156.2s   | 0s             | 0% (needs OPTIMIZE) |
```

**Analysis**:
- batch_delete is only option
- Slower but table stays online
- Requires weekly OPTIMIZE TABLE

**Recommendation**: **Use BATCH DELETE with tuning**
- Start with batch_size=5000
- Monitor replication lag
- Adjust batch_size and batch_delay as needed
- Schedule weekly OPTIMIZE TABLE during lowest traffic period

---

## Summary

### Quick Decision Guide

1. **Can use partitioning?** → DROP PARTITION (best choice)
2. **Need to keep table online 24/7?** → BATCH DELETE (tune carefully)
3. **Have maintenance windows?** → COPY (good for defrag)
4. **Temporary table, no retention?** → TRUNCATE (fastest for full cleanup)

### Key Takeaways

- **DROP PARTITION is fastest** when partitioning is available
- **BATCH DELETE keeps table online** but is slowest and requires OPTIMIZE
- **COPY is good for defrag** but loses data written during copy
- **TRUNCATE is fastest** but removes ALL data

---

**Last Updated**: November 21, 2025  
**For usage examples**: See [USAGE_GUIDE.md](USAGE_GUIDE.md)  
**For production deployment**: See [PRODUCTION_GUIDE.md](PRODUCTION_GUIDE.md)
